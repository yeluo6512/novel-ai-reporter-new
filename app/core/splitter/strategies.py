"""Splitter strategy implementations."""

from __future__ import annotations

from dataclasses import dataclass
import math
import re
from typing import List

from .types import (
    CharacterCountParameters,
    ChapterKeywordParameters,
    FixedCountParameters,
    RatioParameters,
)


@dataclass(slots=True)
class SplitSegment:
    """Represents a single segment generated by a splitter strategy."""

    index: int
    start: int
    end: int
    text: str
    byte_length: int

    @property
    def character_count(self) -> int:
        return self.end - self.start

    @property
    def byte_count(self) -> int:
        return self.byte_length


class TextSplitter:
    """Abstract splitter contract."""

    def split(self, text: str) -> List[SplitSegment]:  # pragma: no cover - interface only
        raise NotImplementedError


class CharacterCountSplitter(TextSplitter):
    """Splits text into roughly equal segments based on character count."""

    def __init__(self, parameters: CharacterCountParameters) -> None:
        self.max_characters = parameters.max_characters

    def split(self, text: str) -> List[SplitSegment]:
        segments: List[SplitSegment] = []
        if not text:
            return segments

        total_length = len(text)
        start = 0
        index = 1
        while start < total_length:
            end = min(total_length, start + self.max_characters)
            segment_text = text[start:end]
            segments.append(
                SplitSegment(
                    index=index,
                    start=start,
                    end=end,
                    text=segment_text,
                    byte_length=len(segment_text.encode("utf-8")),
                )
            )
            start = end
            index += 1
        return segments


class ChapterKeywordSplitter(TextSplitter):
    """Splits text whenever a chapter-style heading regular expression matches."""

    def __init__(self, parameters: ChapterKeywordParameters) -> None:
        self.pattern = re.compile(parameters.pattern)
        self.fallback_max = parameters.fallback_max_characters
        self._fallback_splitter = (
            CharacterCountSplitter(CharacterCountParameters(max_characters=self.fallback_max))
            if self.fallback_max is not None
            else None
        )

    def split(self, text: str) -> List[SplitSegment]:
        if not text:
            return []

        boundaries: List[int] = [0]
        for match in self.pattern.finditer(text):
            position = match.start()
            if position > boundaries[-1]:
                boundaries.append(position)

        segments: List[SplitSegment] = []
        for idx, start in enumerate(boundaries):
            end = boundaries[idx + 1] if idx + 1 < len(boundaries) else len(text)
            if end <= start:
                continue
            segment_text = text[start:end]
            segments.append(
                SplitSegment(
                    index=len(segments) + 1,
                    start=start,
                    end=end,
                    text=segment_text,
                    byte_length=len(segment_text.encode("utf-8")),
                )
            )

        if len(segments) <= 1 and self._fallback_splitter is not None:
            return self._fallback_splitter.split(text)

        return segments


class RatioSplitter(TextSplitter):
    """Splits text into segments sized relative to configured ratios."""

    def __init__(self, parameters: RatioParameters) -> None:
        self.ratios = parameters.ratios

    def split(self, text: str) -> List[SplitSegment]:
        if not text:
            return []

        total_chars = len(text)
        total_weight = sum(self.ratios)
        if math.isclose(total_weight, 0.0):
            return []

        boundaries: List[int] = [0]
        cumulative = 0.0
        for ratio in self.ratios[:-1]:
            cumulative += ratio
            boundary = round(cumulative / total_weight * total_chars)
            boundary = max(boundaries[-1], min(boundary, total_chars))
            boundaries.append(boundary)
        boundaries.append(total_chars)

        segments: List[SplitSegment] = []
        for start, end in zip(boundaries, boundaries[1:], strict=False):
            if end <= start:
                continue
            segment_text = text[start:end]
            segments.append(
                SplitSegment(
                    index=len(segments) + 1,
                    start=start,
                    end=end,
                    text=segment_text,
                    byte_length=len(segment_text.encode("utf-8")),
                )
            )

        if not segments:
            return [
                SplitSegment(
                    index=1,
                    start=0,
                    end=len(text),
                    text=text,
                    byte_length=len(text.encode("utf-8")),
                )
            ]

        # Ensure the final segment always ends exactly at the end of the source text.
        last_segment = segments[-1]
        if last_segment.end != len(text):
            last_segment.end = len(text)
            last_segment.text = text[last_segment.start : len(text)]
            last_segment.byte_length = len(last_segment.text.encode("utf-8"))

        return segments


class FixedCountSplitter(TextSplitter):
    """Splits text into a fixed number of near-equal segments."""

    def __init__(self, parameters: FixedCountParameters) -> None:
        self.segment_count = parameters.segments

    def split(self, text: str) -> List[SplitSegment]:
        if not text:
            return []

        total_chars = len(text)
        segment_count = min(self.segment_count, total_chars) if total_chars > 0 else self.segment_count
        if segment_count <= 0:
            return []

        base_size, remainder = divmod(total_chars, segment_count)
        segments: List[SplitSegment] = []
        cursor = 0
        for index in range(1, segment_count + 1):
            length = base_size + (1 if index <= remainder else 0)
            if index == segment_count:
                end = len(text)
            else:
                end = cursor + length
            segment_text = text[cursor:end]
            segments.append(
                SplitSegment(
                    index=index,
                    start=cursor,
                    end=end,
                    text=segment_text,
                    byte_length=len(segment_text.encode("utf-8")),
                )
            )
            cursor = end

        return segments


__all__ = [
    "SplitSegment",
    "TextSplitter",
    "CharacterCountSplitter",
    "ChapterKeywordSplitter",
    "RatioSplitter",
    "FixedCountSplitter",
]
